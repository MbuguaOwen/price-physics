# src/datasets/shard_dataset.py
import os, numpy as np, pandas as pd, torch
from torch.utils.data import Dataset

class ShardDataset(Dataset):
    def __init__(self, snapshot_csv: str, transform=None):
        df = pd.read_csv(snapshot_csv)
        if "fullpath" not in df.columns:
            # Allow using raw manifest; infer fullpath if missing
            if "relpath" in df.columns:
                root = os.path.dirname(snapshot_csv)
                df["fullpath"] = df["relpath"].apply(lambda p: os.path.join(root, p))
            else:
                raise ValueError("snapshot_csv must have fullpath or relpath column.")
        # keep only rows whose shard exists
        df = df[df["fullpath"].apply(os.path.exists)].reset_index(drop=True)
        self.df = df
        self.transform = transform
        self._cache = {}  # shard_path -> memmap array

    def __len__(self): return len(self.df)

    def __getitem__(self, i):
        row = self.df.iloc[i]
        shard = row["fullpath"]
        idx = int(row["idx_in_shard"])
        arr = self._cache.get(shard)
        if arr is None:
            arr = np.load(shard, mmap_mode="r")  # (B,C,H,W) float32
            self._cache[shard] = arr
        x = np.array(arr[idx], dtype=np.float32)  # copy slice
        if self.transform:
            x = self.transform(x)
        x_t = torch.from_numpy(x)  # (C,H,W)
        y = torch.tensor(0, dtype=torch.long)     # placeholder label
        return x_t, y

